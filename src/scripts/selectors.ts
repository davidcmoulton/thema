import {
  jsonSchemaProperties,
  jsonSchemaTypes,
  microdataItemtype,
  microdataProperty,
  Types
} from '@stencila/schema'
import fs from 'fs'
import path from 'path'

// Target output path for the file containing generated custom selector definitions
const outputPath = path.join(__dirname, '..', 'selectors.css')

/**
 * Generate custom CSS selectors for types and properties
 * in the Stencila Schema.
 *
 * For types, there is only one selector, having the name of the type, and
 * using the `itemtype` attribute eg.
 *
 * ```css
 * :--Article [itemtype~="http://schema.org/Article]
 * :--List [itemtype~="http://schema.org/ItemList]
 * :--CodeChunk [itemtype~="http://schema.stenci.la/CodeChunk]
 * ```
 *
 * For array properties, there are two selectors, for different
 * HTML element roles: `array` and `item`. For example,
 * for the `CreativeWork.authors` property there is...
 *
 * Selector for the property's root element (usually a <ol>)
 *
 * ```css
 * :--authors [data-itemprop~="authors"]
 * ```
 *
 * Selector for the property's item elements (usually <li>s)
 *
 * ```css
 * :--author [itemprop~="author"]
 * ```
 *
 * For other properties, there is just one selector, e.g.
 *
 * ```css
 * :--text [itemprop~="text"]
 * ```
 */
const generateSelectors = async (): Promise<void> => {
  const types = await jsonSchemaTypes()
  const typeSelectorsCss = types
    .map(type => {
      const itemtype = microdataItemtype(type as keyof Types)
      return itemtype !== undefined
        ? `@custom-selector :--${type} [itemtype~='${itemtype}'];\n`
        : ''
    })
    .join('')

  const props = await jsonSchemaProperties()
  const propSelectors = Object.entries(props)
    .map(
      ([name, prop]): Record<string, string> => {
        if (prop.isPlural) {
          const [[arrayAttr, arrayValue]] = Object.entries(
            microdataProperty(name, 'array')
          )
          const [[itemAttr, itemValue]] = Object.entries(
            microdataProperty(name, 'item')
          )
          return {
            [name]: `[${arrayAttr}~='${arrayValue}']`,
            [name.slice(0, -1)]: `[${itemAttr}~='${itemValue}']`
          }
        } else {
          const [[attr, value]] = Object.entries(microdataProperty(name))
          return {
            [name]: `[${attr}~='${value}']`
          }
        }
      }
    )
    .reduce((prev, curr) => {
      for (const [key, value] of Object.entries(curr)) {
        if (key in prev && !prev[key].includes(value)) prev[key] += `, ${value}`
        else prev[key] = value
      }
      return prev
    }, {})
  const propSelectorsCss = Object.entries(propSelectors)
    .map(([name, selectors]) => `@custom-selector :--${name} ${selectors}`)
    .join('\n')

  const doc = `/* Generated by ${path.basename(__filename)}. Do not edit. */

/**
 * Type selectors
 */
${typeSelectorsCss}

/**
 * Property selectors
 */
${propSelectorsCss}`

  return fs.writeFile(outputPath, doc, () => doc)
}

// eslint-disable-next-line @typescript-eslint/no-floating-promises
if (module.parent === null) generateSelectors()
